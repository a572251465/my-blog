<div align = "center"><h1>事件循环</h1></div>

![事件循环](https://img-blog.csdnimg.cn/4698b74da7724df3b718d73c7ca7d2e5.png#pic_center)

## 疑问

> 众所周知浏览器的主线程是单线程的，在正真执行过程中是如何处理代码执行/ dom 变化/ 渲染等情况的呢

- 通过上述实例中可以看到，我们触发的任务都会被封装成功一个个宏任务添加到消息队列中
- 只不过是事件循环机制会从队列中拿到一个个任务执行
- 但是针对延时任务，我们会有单独的延时队列，在触发延时功能的时候，会识别延时任务的开始时间/ 延时时间/ 结束时间等，将他们放置到延时队列中
- 每次执行事件循环的时候都会检查延迟队列中的任务是否到期，如果到期了将其添加到消息队列中
- 通过以上情况可以得知：延迟队列的执行是不精准的。队列之前的任务执行时间会耽误延时任务的执行。例如：

```javascript
setTimeout(() => {
  console.log("测试结果");
}, 0);

let i = 0;
for (; i < 100000000000; i += 1) {}
```

-
- 通过上述的实例可以得出，打印逻辑并不是立刻执行，而是等到同步执行结束后才会执行
- 那如何保证任务的优先级以及准确性呢？？？
  - 事件循环中引入了`微任务`的概念。
  - 每个宏任务的执行都会创建自己的微任务队列，将触发的微任务添加到队列中
  - 微任务会在渲染之前都执行结束
