## 严格模式

> ECMAScript 5 首次引入`严格模式`的概念。严格模式用于选择以更严格的条件检查 JavaScript 代码错误，可以应用到全局，也可以应用到函数内部。严格模式的好处是可以提早发现错误，因此可以捕获某些 ECMAScript 问题导致的编程错误

### 选择使用

> 要选择使用严格模式，需要使用严格模式`编译指令`

```js
'use strict'
```

> 这样一个即使在 ECMAScript 3 中也有效的字符串，可以兼容不支持严格模式的 JavaScript 引擎。支持严格模式的引擎会启用严格模式，而不支持的引擎则会将这个编译指示当成一个未赋值的字符串字面量。如果把这个编译指示应用到全局作用域，即函数外部，则整个脚本都会按照严格模式来解析。这意味着在最终会与其他脚本拼接为一个文件的脚本中添加了编译指示，会将该文件中的所有 JavaScript 置于严格模式之下

### 实例

- 不允许意外创建全局变量

```js
message = 'hello world' // 非模式模式下，此变量会升级为全局变量
```

- 无法在变量上直接使用`delete`

```js
let color = 'red'
delete color // 非严格模式下静默失败。严格模式下会报错
```

- 对象中不允许存在相同的 key

```js
let person = {name: '11', name: '22'] // 非严格模式下后者生效，严格模式下直接报错
```

- 必须要求函数参数必须唯一

```js
function sum(num, num) {} // 非严格模式下第二个生效。严格模式下报错
```

- arguments 对象在严格模式下也会有一定的变化

  - 在非严格模式下，修改命名参数也会修改 arguments 对象中的值。而在严格模式下，命名参数和 arguments 是相互独立的
  - arguments.callee 和 arguments.caller。在非严格模式下，它们分别引用函数本身和调用函数。在严格模式下，访问这两个属性中的任何一个都会抛出 TypeError

- ES6 增加了剩余操作符、解构操作符和默认参数等新特性，在函数内部跟严格模式不能一起使用

- 严格模式下`with`语法不能使用

- 严格模式下不能使用八进制的字面量
