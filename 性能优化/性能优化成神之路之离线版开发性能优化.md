## 前言
>  - 今天主要是分享下公司的产品XXX是如何做优化的。那有人会问：是不是跟部分文章一样从11s到1s启动啊，是不是优化到网页秒速打开啊。
>  - 本人不敢说从`11s => 1s`，也不敢说多么多么厉害。不过从数据以及体验来看，优化的效果确实还可以。
>  - 只要是代码写的不是很差的，我感觉部分优化都是在做`取舍`。重点优化客户容易关注的地方

## 问题
> 接下来说下项目中遇到的问题，针对不同的问题做特殊的优化
- 为了图片不失真，登录页面大LOGO高达1M。造成了初次加载卡顿(第二次有缓存会好点)
- UI设计指定的字体大小是`10M`. 而且还无法提取部分字体
- 网络传输的内容过大，即使js/ css经过压缩了。有的js大小依旧是`几百K`
- 组件没有按需导入。导致所有的组件都打包到一个`bandle`去了
- 小图片过多造成了请求过多，出现了请求阻塞

## 解决方案
> 针对以上的问题，进行一一解决。从效果上看确实提速不少，这里会给大家一一分析下，同时也是希望能帮助到大家

### 1. 问题1 LOGO过大
> 在`程序猿`的世界中，往往一张好看的大logo图片能胜过万万千千行代码。但是这类的图片难免就会很大。一旦压缩后就会有点失真，尤其是在`1px眼`的测试工程师眼中更为明显了。所以图片大还要求不失真，最可恨的是必须不能卡顿。而作为`程序猿`的我们必须想办法解决问题
- 采用渐进式图片加载方案进行图片加载。
	- 这种方案就是一个从模糊到清晰的过程
	- 首先需要两张图片(一张很小的替代图，一张很大的原图)
	- 我们刚默认加载的是替代图。这种图会失真，同样我们需要在图片上加上蒙层
	- 当页面开始加载过程中，蒙层是从1到0的过程。同样执行完`load`时间后，我们会动态加载原图，来替换原来的替代图
```ts
const progressiveLoadImg = () => {
  // 设置地址 如果是本地直接在xxx上获取 反之当前服务器
  const { origin } = location
  const reqImgURL = `${
    origin.includes("localhost") ? "http://10.xxx.31.xxx" : origin
  }${BASE_COMMON_PREFIX}/assetFiles/earth.webp`

  // 开始加载图片
  const img = new Image()
  img.src = reqImgURL
  img.onload = () => {
    ;(proxy?.$refs["imgRef"] as HTMLImageElement).src = img.src
  }
}
```
- 同时可以将很大的`png`的图片转换为`webp`图片，在保证不失真的情况下可以将`1M`图片转换`88K`. 大大减少的图片体积，加快传输速度（`只是单单执行这个方案也会提速很多哦`）

### 2. 字体库很大，加载缓慢
> 以我们的真实项目为例。根据UI设计师给出的字体，一个`normal`类型的字体的大小就10M。对于网速很好的同学可能觉得没什么，但是如果是网速不好/ 弱网环境下，整个页面就会一直`loading`中,给客户的体验很不好
- 在实际的项目中就算页面初期以同步的方式加载字体，字体也不会立马生效的，因为下载时需要一个过程的，尤其是网速慢的情况下
- 所以采用异步的方式，就是我们将`@font-face`会单独封装到css中。在页面`load`事件执行后，动态请求字体资源。
- 同样为了避免字体使用的时候出现空白现象，所以`font-display`需要设置特殊的值
 ```js
const dynamicCreateCss = (closeFn: INormalFn) => {
  const link = document.createElement("link")
  link.rel = "stylesheet"
  // 设置跨域
  link.crossOrigin = "anonymous"
  link.href = `${reqCommonURL}/font-family.css`
  link.onload = closeFn
  document.head.appendChild(link)

  closeFn()
}
 ```
 ```css
 @font-face {
  font-family: "normal";
  src: url("./style-fonts.ttf");
  font-display: swap;
}
 ```
 ### 3. 常规的方案
 - 针对传输过程内容过大的问题，`node`或是`nginx`端必须开启`gzip`压缩。体积能少百分之60以上，同样能够加快传输速度
 - 在项目开发中，可以更多的使用动态导入的形式来引入组件。因为`import`语法有切割代码块的功能。为了减少体积没必要将所有的文件都打包到一个文件中
 - 如果是小图片过大，建议仔细分析下哪中大小的图片更多些，可以在不过多增加体积的情况下将图片转换为base64位，避免多余的请求
 ### 4. 补充
 1. 如果项目类似与是`B站`这种类型的话，可以更多的使用`webp`图片，同时使用HTTP2. 来同时进行请求

## 结束
> 大体的分析就这么多。我觉得想要提高网站性能主要是还是分析哪里会出问题，利用一些工具`lighthouse` 以及`webpagetest`等网站进行分析，最后逐一击破

> 关注我的[GitHub博客](https://github.com/a572251465/my-blog),会不断更新基础知识/ 源码分析/ 工程化等
